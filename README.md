# CSCI2270-GraphingFinal Avery Anderson
This is the repository for the final project in my class CSCI-2270 Data Structures.

Compiling:  In order to compile the program make sure roadTripping.hpp, roadTripping.cpp and main.cpp are all in the same directory, then type the following into the command line. 
	"g++ -std=c++11 roadTripping.cpp main.cpp -o runner"

Running:  In order to run the program make sure the file "CitySet.txt" is also in the directory and then type "./runner" into the command line.

Optional Files: There are three optional files in this repository named "Itinerary1.txt", "Itinerary2.txt", and "Itinerary3.txt". These files contain examples of the lists of activities and cities that run the program.  These lists called Itineraries are formatted so their first entry is the name of a city within the graph, and every following item of the list, be it a city name or an activity is found on its own line.  When the program runs it provides an option to load an itinerary file, or you can choose to construct an itinerary manually through the program's menus.

Functionality: This program reads in the text file "CitySet.txt" and uses it to construct a weighted graph. The nodes of this graph are a collection of ten cities locations from around the us, and each city has a linked list containing all of the activities that one would be able to do in said location.  For example in Canyon_Village one can "see_yellowstone" and in Keystone one can "visit_mount_rushmore".  The goal of this program was to assist users in the planning of potential road trips, after the program creates the graph of cities, users are able to modify the by adding or deleting connections and activies between and within any city on the graph, and they can also load or build itineraries to run through the graph.  Itineraries within the context of this program are a list of cities one would like to visit and activities that one would like to do over the course of their trip. Itineraries have two constraints that must be resolved before they can be run, they must begin with a city so the program knows exactly where to begin, and they must have at least two items so the program has somewhere to go.  So long as an itinerary meets both of these requirements, whether they be a a simple list of cities(Itinerary1.txt), a list of one city and many activites(Itinerary2.txt) or some mixture of the two(Itinerary3.txt), the program will use Dijkstra's method to connect every step of the journey in the shortest possible path without visiting any location twice.  Note this is not truly the most efficient path, but rather the shortest path between each step. For example the Itinerary Boulder -> Las_Vegas -> Denver will concatentate the shortest path from Boulder to Las_Vegas with the shortest path from Las_Vegas to Denver that doesn't re-use any cities.  If no such path can be created the program will instead print out which node it failed to access.

Example Run:  After compiling the code start it in the command line.  You will be presented with the message "The city of Boulder is already in the map. The duplicate was not added."  This is due to the fact that I added a duplicate in the CitySet.txt file in order to show of the file's ability to avoid adding the same city twice. It has the same functionality when it comes to duplicating connections and activies as well.  After that line you'll be presented with the main menu of the program.  First type "1" and press enter in order to see the graph as parsed from the textfile.  Now lets add a connection between Boulder and Canyon Village.  Choosing Option "2", type "Add" and press enter. This will take you to the add connection menu of the program. When prompted type "Boulder", "Canyon_Village" and "584" as the two cities are 584 miles away from each other. After all three items have been enterred you'll find yourself at the main menu again, but if you print the graph a second time you'll see a new connection has been added for both cities.  The functions for removing city connections, adding and removing activities from cities, and adding and removing items from itineraries are almost identical to this process, so let's move to importing an itinerary.  Choose option "4" from the main menu, and when prompted provide the name "Itinerary2.txt". This will load the itinerary into the program. To do any Itinerary based operations choose menu option "5".  Typing "See" will print the itinerary again, typing "Modify" will allow you to add or remove items from the itinerary, but we only want to run the itinerary, so type "Run". This will print out each leg of the journey as described by the itinerary, as well as the final path and final path length of the road trip. In this example, the road-trippers should go from Omaha to Keystone to Canyon_Village to Boulder to Denver before finally ending in Alamosa with a total distance of 1878 miles. You can continue to load or build more itineraries, and run them without issue. When finished simply type "6" and the program will end.

Dependencies:  The only files that this program really needs to run are the header, implementation and main file and the CitySet.txt file. Although the Itinerary files save a lot of time going through menus.

System Requirements: This program was written on a Linux VM. It would probalby work best in a similar environment.

Bugs:  This program can catch most redundancies or mis-entries it encounters.  If for example one tries to add connections between cities that already exist, or tries to delete objects that do not exist, it will yell at them.  However there are some issues that I couldn't figure out how to avoid.  If for example one were to mispell one of the activities in their itinerary, the loop will never find a solution, though it will still terminate. I have also found one situation where the code will abort.  If when adding a connection between cities one were to type any character that is not a number in the "distance" parameter the code fails. This happens because the stoi function doesn't know how to handle these arguments and breaks the program.  Not knowing how to catch this error, I'm relying on the user to not put invalid inputs.